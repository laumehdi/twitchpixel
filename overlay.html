<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Overlay Alpha Gold V23 - Random Events</title>
  <style>
    /* === Solarized Palette Reference ===
       base03:#002b36 base02:#073642 base01:#586e75 base00:#657b83
       base0:#839496  base1:#93a1a1  base2:#eee8d5  base3:#fdf6e3
       yellow:#b58900 orange:#cb4b16 red:#dc322f magenta:#d33682
       violet:#6c71c4 blue:#268bd2   cyan:#2aa198   green:#859900 */

    html, body { 
      margin: 0; padding: 0; background: transparent !important; 
      overflow: hidden; width: 1920px; height: 1080px;
      font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    }
    #container { position: absolute; width: 100%; height: 100%; top: 0; left: 0; pointer-events: none; }

    #status {
      position: absolute; top: 10px; left: 10px;
      color: #ffcc00; font-weight: bold; font-size: 24px;
      text-shadow: 2px 2px 0 #000; z-index: 99999; font-family: monospace;
      background: rgba(0,0,0,0.7); border-radius: 8px; padding: 10px; display: none; 
    }
    
    .item { 
      position: absolute; top: 0; left: 0; display: flex;
      flex-direction: column; align-items: center; width: 165px; will-change: transform; 
    }
    canvas.pixel-art { 
      image-rendering: pixelated; width: 165px; height: 165px; 
      background: transparent; z-index: 2; 
    }

    @keyframes jumpBounce { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-30px)} }
    .jumping canvas { animation: jumpBounce 0.8s ease-in-out infinite; }
    .is-sub canvas { filter: brightness(1.15); }
    
    .nick { 
      color: white; font-weight: 900; font-size: 22px; width: 280px; 
      text-align: center; margin-top: 2px; white-space: nowrap; 
      text-shadow: 2px 2px 0 #000; z-index: 3;
    }
    .is-sub .nick { color: #FFD700; }

    /* === SHOWCASE === */
    .showcase {
      position: fixed !important; top: 50% !important; left: 50% !important;
      z-index: 99999 !important; will-change: transform;
      animation: superDance 0.8s infinite ease-in-out !important;
    }
    .showcase::before {
      content: ''; position: absolute; top: 50%; left: 50%;
      width: 280px; height: 280px; transform: translate(-50%, -60%); 
      z-index: 1; border-radius: 50%;
      background: radial-gradient(circle, rgba(255,255,224,0.9) 0%, rgba(255,215,0,0.5) 40%, transparent 70%);
      animation: auraPulse 1.5s infinite alternate ease-in-out;
    }
    .showcase canvas { filter: brightness(1.1); }
    .showcase .nick { font-size: 33px !important; text-shadow: 3px 3px 0 #000, 0 0 10px rgba(0,0,0,0.5); margin-top: 15px; }
    @keyframes superDance {
      0%{transform:translate(-50%,-50%) scale(4.1) rotate(0deg)}
      25%{transform:translate(-50%,-50%) scale(4.4) rotate(-5deg)}
      50%{transform:translate(-50%,-50%) scale(4.1) rotate(0deg) translateY(-15px)}
      75%{transform:translate(-50%,-50%) scale(4.4) rotate(5deg)}
      100%{transform:translate(-50%,-50%) scale(4.1) rotate(0deg)}
    }
    @keyframes auraPulse {
      0%{transform:translate(-50%,-60%) scale(1);opacity:0.7}
      100%{transform:translate(-50%,-60%) scale(1.15);opacity:1}
    }

    .hidden { display: none !important; }
    .waiting { opacity: 0; }
    .spiral-to-lane { position: absolute !important; z-index: 99998 !important; will-change: transform; pointer-events: none; }
    .spiral-to-lane .nick { transition: font-size 1.2s ease-in; font-size: 22px !important; }

    /* === FIGHT HUD === */
    #fight-hud {
      display: none; position: fixed; top: 0; left: 0; width: 1920px; height: 1080px;
      z-index: 90000; pointer-events: none;
    }
    .hp-bar-container {
      position: absolute; top: 40px; width: 700px; height: 40px;
      border-radius: 8px; overflow: hidden;
      border: 3px solid #fff; box-shadow: 0 0 20px rgba(0,0,0,0.7);
    }
    .hp-bar-container.left  { left: 50px; }
    .hp-bar-container.right { right: 50px; }
    .hp-bar-bg { width: 100%; height: 100%; background: #333; }
    .hp-bar-fill { height: 100%; transition: width 0.3s ease-out; }
    .hp-bar-fill.left  { background: linear-gradient(90deg, #dc322f, #ff6b6b); float: left; }
    .hp-bar-fill.right { background: linear-gradient(90deg, #6bc5ff, #268bd2); float: right; }
    .hp-label {
      position: absolute; top: 44px; font-size: 22px; font-weight: 900;
      color: white; text-shadow: 2px 2px 0 #000;
    }
    .hp-label.left  { left: 50px; }
    .hp-label.right { right: 50px; }

    #fight-text {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
      font-size: 120px; font-weight: 900; color: #dc322f;
      text-shadow: 4px 4px 0 #000, 0 0 40px rgba(220,50,47,0.6);
      font-family: 'Impact', 'Arial Black', sans-serif;
      letter-spacing: 10px; display: none;
      animation: fightPulse 0.3s ease-in-out 3;
    }
    @keyframes fightPulse {
      0%,100%{transform:translate(-50%,-50%) scale(1)} 50%{transform:translate(-50%,-50%) scale(1.15)}
    }

    #fight-winner-text {
      position: absolute; top: 35%; left: 50%; transform: translate(-50%,-50%);
      font-size: 70px; font-weight: 900; color: #b58900;
      text-shadow: 3px 3px 0 #000, 0 0 30px rgba(181,137,0,0.5);
      font-family: 'Impact', 'Arial Black', sans-serif;
      display: none;
    }

    /* === SOLARIZED TEST PANEL === */
    :root {
      --sol-bg:#fdf6e3; --sol-bg-alt:#eee8d5; --sol-border:#93a1a1;
      --sol-text:#657b83; --sol-text-dim:#93a1a1; --sol-text-emph:#586e75;
      --sol-shadow:rgba(0,0,0,0.12); --sol-scrollbar:#93a1a1; --sol-line-border:#eee8d5;
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --sol-bg:#002b36; --sol-bg-alt:#073642; --sol-border:#073642;
        --sol-text:#839496; --sol-text-dim:#586e75; --sol-text-emph:#93a1a1;
        --sol-shadow:rgba(0,0,0,0.5); --sol-scrollbar:#586e75; --sol-line-border:#073642;
      }
    }
    #test-bar {
      display: none; position: fixed; bottom: 10px; left: 10px; z-index: 100000;
      pointer-events: auto; font-family: 'Segoe UI', sans-serif;
      flex-direction: row; align-items: flex-end; gap: 10px;
    }
    #test-buttons {
      display: flex; gap: 6px; flex-wrap: wrap; max-width: 380px; padding: 10px;
      background: var(--sol-bg); border-radius: 10px; border: 1px solid var(--sol-border);
      box-shadow: 0 4px 20px var(--sol-shadow);
    }
    #test-buttons button {
      padding: 9px 14px; border: none; border-radius: 6px; font-size: 13px;
      font-weight: 700; cursor: pointer; transition: transform 0.1s, filter 0.1s;
      text-transform: uppercase; letter-spacing: 0.3px; font-family: 'Segoe UI', sans-serif;
    }
    #test-buttons button:hover { transform: scale(1.05); filter: brightness(1.15); }
    #test-buttons button:active { transform: scale(0.97); }

    .btn-user  { background:#859900; color:#fdf6e3; }
    .btn-sub   { background:#b58900; color:#fdf6e3; }
    .btn-speed { background:#268bd2; color:#fdf6e3; }
    .btn-rain  { background:#6c71c4; color:#fdf6e3; }
    .btn-boom  { background:#dc322f; color:#fdf6e3; }
    .btn-pogo  { background:#d33682; color:#fdf6e3; }
    .btn-fight { background:#cb4b16; color:#fdf6e3; }
    .btn-volcano { background:#b58900; color:#fdf6e3; }
    .btn-confetti { background:#2aa198; color:#fdf6e3; }
    .btn-exit  { background:#586e75; color:#fdf6e3; }
    .btn-clear { background:#073642; color:#93a1a1; }
    .btn-speed.active { box-shadow: 0 0 0 2px #2aa198; }

    #test-console {
      width: 500px; height: 260px; background: var(--sol-bg);
      border: 1px solid var(--sol-border); border-radius: 10px;
      box-shadow: 0 4px 20px var(--sol-shadow);
      font-family: 'Cascadia Code','Fira Code','Consolas',monospace;
      font-size: 12px; overflow: hidden; display: flex; flex-direction: column;
    }
    #test-console-header {
      padding: 6px 12px; background: var(--sol-bg-alt); color: var(--sol-text-emph);
      font-size: 11px; font-weight: bold; text-transform: uppercase;
      letter-spacing: 1px; border-bottom: 1px solid var(--sol-border);
      display: flex; justify-content: space-between;
    }
    #test-console-body { flex:1; overflow-y:auto; padding:8px 12px; display:flex; flex-direction:column; }
    #test-console-body::-webkit-scrollbar { width: 6px; }
    #test-console-body::-webkit-scrollbar-track { background: var(--sol-bg); }
    #test-console-body::-webkit-scrollbar-thumb { background: var(--sol-scrollbar); border-radius: 3px; }

    .log-line { padding:2px 0; line-height:1.5; color:var(--sol-text); border-bottom:1px solid var(--sol-line-border); }
    .log-line .time { color:var(--sol-text-dim); }
    .log-line .tag-lane  { color:#2aa198; }
    .log-line .tag-user  { color:#859900; }
    .log-line .tag-sub   { color:#b58900; }
    .log-line .tag-boom  { color:#dc322f; }
    .log-line .tag-pogo  { color:#d33682; }
    .log-line .tag-fight { color:#cb4b16; }
    .log-line .tag-volcano { color:#b58900; }
    .log-line .tag-confetti { color:#2aa198; }
    .log-line .tag-speed { color:#268bd2; }
    .log-line .tag-rain  { color:#6c71c4; }
    .log-line .tag-event { color:#2aa198; }
    .log-line .tag-info  { color:var(--sol-text-dim); }
  </style>
</head>
<body>
  <div id="status">CARGANDO...</div>
  <div id="container"></div>

  <!-- FIGHT HUD -->
  <div id="fight-hud">
    <div class="hp-bar-container left"><div class="hp-bar-bg"><div class="hp-bar-fill left" id="hp-left" style="width:100%"></div></div></div>
    <div class="hp-label left" id="hp-label-left">EQUIPO ROJO</div>
    <div class="hp-bar-container right"><div class="hp-bar-bg"><div class="hp-bar-fill right" id="hp-right" style="width:100%"></div></div></div>
    <div class="hp-label right" id="hp-label-right">EQUIPO AZUL</div>
    <div id="fight-text">FIGHT!</div>
    <div id="fight-winner-text"></div>
  </div>

  <!-- TEST BAR -->
  <div id="test-bar">
    <div id="test-buttons">
      <button class="btn-user" onclick="testAddUser()">‚ûï Usuario</button>
      <button class="btn-sub" onclick="testAddSub()">‚≠ê Sub</button>
      <button class="btn-speed" id="btn-spd1" onclick="testSpeed(1)">üê¢ Vel 1</button>
      <button class="btn-speed" id="btn-spd2" onclick="testSpeed(2)">üêá Vel 2</button>
      <button class="btn-rain" onclick="toggleRain()">üåßÔ∏è Lluvia</button>
      <button class="btn-boom" onclick="triggerBoom()">üí• Boom</button>
      <button class="btn-pogo" onclick="triggerPogo()">ü¶ò Pogo</button>
      <button class="btn-fight" onclick="triggerFight()">‚öîÔ∏è Fight</button>
      <button class="btn-volcano" onclick="triggerVolcano()">üåã Volc√°n</button>
      <button class="btn-confetti" onclick="triggerConfetti()">üéä Salto</button>
      <button class="btn-clear" onclick="removeAllDrawingsGlobal(); logConsole('info','Limpiado')">üóëÔ∏è</button>
      <button class="btn-exit" onclick="toggleTest()">‚ùå Salir</button>
    </div>
    <div id="test-console">
      <div id="test-console-header">
        <span>üìü Consola</span>
        <span id="console-stats"></span>
      </div>
      <div id="test-console-body"></div>
    </div>
  </div>

  <script>
    const urlParams = new URLSearchParams(window.location.search);
    let channelParam = urlParams.get('channel');
    if (!channelParam && window.location.search.length > 1) channelParam = window.location.search.substring(1).replace('=', '');
    const CHANNEL = channelParam || 'laumehdi'; 
    
    const colors = ['transparent','#000000','#aa0000','#00aa00','#aa5500','#0000aa','#aa00aa','#00aaaa','#aaaaaa','#555555','#ff5555','#55ff55','#ffff55','#5555ff','#ff55ff','#55ffff','#ffffff'];
    const TEST_CODE = "v2000000008751AB52361D2B535F574F83769CC2C3C7FFCCAAFF004D00E436FFEC2729ADFFFF77A8FFF1E8_AAAAAAAAAAAAmQAAAA3QAAmZqqu8zd7uCZmqq7zM3u4AIiM0REjdMAAiY3dEQRMwAAZnd3GIVQMAAAB3cYhVUBEREQABEREQABABAAABABEAEAABAAEBAAAQEREAAQEAABAREAABAQAAEBAAEBABAAAAEAEREAEAAAAREA==";
    const RANDOM_NAMES = ['PixelMaster','xDarkSoul','CoolCat99','TwitchFan','GamerGirl','NightOwl42','StarPlayer','MoonWalk','FireStorm','IceQueen','ShadowNinja','ThunderBolt','CosmicDust','NeonLight','RetroGamer','DigitalArt','PixelPunk','ChipTune','BitCrusher','WaveRider','CyberWolf','TurboFox','LaserBeam','RocketFuel','QuantumLeap','ZeroGravity','SuperNova','MegaByte','HyperLink','GlitchHop'];

    let drawings = [], testMode = false, rainMode = false;
    let subQueue = [], isShowcaseBusy = false, ws = null, activeCodes = new Set();
    let testUserCounter = 0, globalSpeedMultiplier = 0.54;
    let lastTime = performance.now();

    // === EVENT SYSTEM STATE ===
    let activeEvent = null; // 'boom' | 'pogo' | 'fight' | null
    let eventTimer = null;
    let randomEventScheduler = null;
    let fightState = null;

    const LANES = [10, 40, 70, 100], SPEEDS = [2, 3.5, 2.5, 4.5], Z_INDEXES = [5, 20, 10, 30];

    // === CONSOLA ===
    function logConsole(tag, msg) {
      if (!testMode) return;
      const body = document.getElementById('test-console-body');
      const t = new Date().toLocaleTimeString('es', {hour12:false});
      const line = document.createElement('div');
      line.className = 'log-line';
      line.innerHTML = `<span class="time">${t}</span> <span class="tag-${tag}">[${tag.toUpperCase()}]</span> ${msg}`;
      body.appendChild(line);
      body.scrollTop = body.scrollHeight;
      while (body.children.length > 200) body.removeChild(body.firstChild);
      updateConsoleStats();
    }
    function updateConsoleStats() {
      const el = document.getElementById('console-stats');
      if (!el) return;
      const lc = [0,0,0,0];
      drawings.forEach(d => { if (!d.el.classList.contains('showcase')&&!d.el.classList.contains('hidden')) lc[d.lane]++; });
      const evtStr = activeEvent ? ` | üé™ ${activeEvent.toUpperCase()}` : '';
      el.textContent = `Total:${drawings.length} | C1:${lc[0]} C2:${lc[1]} C3:${lc[2]} C4:${lc[3]} | Vel:${globalSpeedMultiplier>=0.9?'2':'1'}${evtStr}`;
    }

    function getMinXInLane(laneIdx, excludeObj) {
      let minX = Infinity;
      drawings.forEach(d => {
        if (d !== excludeObj && d.lane === laneIdx && !d.el.classList.contains('showcase')) {
          if (d.x < minX) minX = d.x;
        }
      });
      return minX === Infinity ? -200 : minX;
    }

    function assignBoomPhysics(d) {
      d.el.classList.remove('jumping');
      const angle = Math.random() * Math.PI * 2;
      const speed = 3 + Math.random() * 5;
      d.boomVx = Math.cos(angle) * speed;
      d.boomVy = Math.sin(angle) * speed;
      d.boomRot = 0;
      d.boomRotSpeed = (Math.random() - 0.5) * 12;
    }

    // Restore all drawings to normal lane walking after any event
    function restoreToLanes() {
      drawings.forEach((d, idx) => {
        if (d.el.classList.contains('showcase') || d.el.classList.contains('waiting')) return;
        d.el.style.opacity = 1;
        d.el.classList.remove('jumping');
        const laneIdx = idx % LANES.length;
        d.lane = laneIdx; d.y = LANES[laneIdx]; d.speed = SPEEDS[laneIdx];
        d.el.style.zIndex = Z_INDEXES[laneIdx];
        d.x = getMinXInLane(laneIdx, d) - 350;
        d.el.style.transform = `translate3d(${d.x}px, ${d.y}px, 0)`;
        d.fightSide = undefined;
        d.fightDead = false;
      });
    }

    function endEvent() {
      if (eventTimer) { clearTimeout(eventTimer); eventTimer = null; }
      const evName = activeEvent;
      activeEvent = null;
      fightState = null;
      document.getElementById('fight-hud').style.display = 'none';
      restoreToLanes();
      logConsole('event', `üé™ Evento <b>${evName}</b> terminado ‚Äî volviendo a carriles`);
      updateConsoleStats();
    }

    function isEventActive() { return activeEvent !== null; }

    // === EXPLOSION PARTICLES ===
    function spawnExplosion(x, y) {
      const particleCount = 12;
      const container = document.getElementById('container');
      for (let i = 0; i < particleCount; i++) {
        const p = document.createElement('div');
        const size = 6 + Math.random() * 10;
        const angle = (Math.PI * 2 / particleCount) * i + (Math.random() - 0.5) * 0.5;
        const speed = 80 + Math.random() * 120;
        const dx = Math.cos(angle) * speed;
        const dy = Math.sin(angle) * speed;
        const colors = ['#dc322f','#cb4b16','#b58900','#ffff55','#ff5555','#ffffff'];
        const color = colors[Math.floor(Math.random() * colors.length)];
        
        p.style.cssText = `position:absolute;left:${x + 80}px;top:${y + 80}px;width:${size}px;height:${size}px;background:${color};border-radius:50%;pointer-events:none;z-index:99990;box-shadow:0 0 ${size}px ${color};`;
        container.appendChild(p);
        
        const startTime = performance.now();
        const duration = 400 + Math.random() * 300;
        
        function animParticle(now) {
          const elapsed = now - startTime;
          const progress = Math.min(elapsed / duration, 1);
          const ease = 1 - Math.pow(1 - progress, 2);
          const px = x + 80 + dx * ease;
          const py = y + 80 + dy * ease - 30 * ease; // slight upward arc
          const scale = 1 - progress * 0.7;
          const opacity = 1 - progress;
          p.style.transform = `translate(${dx * ease}px, ${dy * ease - 40 * ease}px) scale(${scale})`;
          p.style.opacity = opacity;
          if (progress < 1) requestAnimationFrame(animParticle);
          else p.remove();
        }
        requestAnimationFrame(animParticle);
      }
    }

    // ==============================================================
    //  MAIN ANIMATION LOOP
    // ==============================================================
    function animate(currentTime) {
      if (!currentTime) currentTime = performance.now();
      const dt = Math.min((currentTime - lastTime) / 16.666, 3);
      lastTime = currentTime;
      const now = Date.now();

      // Fight logic tick
      if (activeEvent === 'fight' && fightState && fightState.phase === 'fighting') {
        fightTick(dt);
      }

      for (let i = drawings.length - 1; i >= 0; i--) {
        let d = drawings[i];
        if (d.el.classList.contains('showcase') || d.el.classList.contains('hidden') || d.el.classList.contains('spiral-to-lane')) continue;
        if (d.el.classList.contains('waiting')) { d.el.style.transform = 'translate3d(-500px,-500px,0)'; continue; }

        // === BOOM ===
        if (activeEvent === 'boom') {
          d.el.style.opacity = 1;
          d.x += d.boomVx * dt; d.y += d.boomVy * dt; d.boomRot += d.boomRotSpeed * dt;
          if (d.x < -80) { d.x=-80; d.boomVx=Math.abs(d.boomVx); }
          if (d.x > 1840) { d.x=1840; d.boomVx=-Math.abs(d.boomVx); }
          if (d.y < -80) { d.y=-80; d.boomVy=Math.abs(d.boomVy); }
          if (d.y > 980) { d.y=980; d.boomVy=-Math.abs(d.boomVy); }
          d.el.style.transform = `translate3d(${d.x}px,${d.y}px,0) rotate(${d.boomRot}deg)`;
          continue;
        }

        // === POGO ===
        if (activeEvent === 'pogo') {
          d.el.style.opacity = 1;
          d.boomVy += 0.35 * dt; // gravity (lower = longer airtime)
          d.y += d.boomVy * dt;
          d.x += d.boomVx * dt;
          // bounce off floor ‚Äî BIG launch upward
          if (d.y > 820) { d.y = 820; d.boomVy = -(12 + Math.random() * 10); }
          // bounce off walls
          if (d.x < -80) { d.x = -80; d.boomVx = Math.abs(d.boomVx); }
          if (d.x > 1840) { d.x = 1840; d.boomVx = -Math.abs(d.boomVx); }
          d.boomRot += d.boomRotSpeed * dt;
          d.el.style.transform = `translate3d(${d.x}px,${d.y}px,0) rotate(${d.boomRot}deg)`;
          continue;
        }

        // === VOLCANO ===
        if (activeEvent === 'volcano') {
          d.el.style.opacity = 1;
          d.boomVy += 0.25 * dt; // lighter gravity for high arcs
          d.y += d.boomVy * dt;
          d.x += d.boomVx * dt;
          // Slight wind drift
          d.boomVx += Math.sin(now / 1000 + d.fightPhase) * 0.02 * dt;
          // When they fall below screen, re-erupt from volcano
          if (d.y > 1100) {
            d.x = 880 + (Math.random() - 0.5) * 200; // center-ish
            d.y = 1080;
            d.boomVy = -(16 + Math.random() * 14); // big upward blast
            d.boomVx = (Math.random() - 0.5) * 10; // spread out horizontally
          }
          // Cap at top of screen ‚Äî bounce gently
          if (d.y < -200) { d.y = -200; d.boomVy = Math.abs(d.boomVy) * 0.3; }
          d.boomRot += d.boomRotSpeed * dt;
          d.el.style.transform = `translate3d(${d.x}px,${d.y}px,0) rotate(${d.boomRot}deg)`;
          continue;
        }

        // === CONFETTI (Salto) ===
        if (activeEvent === 'confetti') {
          d.el.style.opacity = 1;
          // Strong gravity ‚Äî they have WEIGHT, fall fast
          d.boomVy += 0.55 * dt;
          d.y += d.boomVy * dt;
          d.x += d.boomVx * dt;
          // Horizontal wobble like paper
          d.boomVx += Math.sin(now / 300 + d.fightPhase * 4) * 0.08 * dt;
          // Dampen horizontal slightly
          d.boomVx *= 0.999;
          // When hitting the floor, re-launch upward (slower going up, fast coming down)
          if (d.y > 950) {
            d.y = 950;
            d.boomVy = -(10 + Math.random() * 16); // upward impulse (slower than gravity pull)
            d.boomVx = (Math.random() - 0.5) * 8; // new random horizontal spread
          }
          // Bounce off walls
          if (d.x < -80) { d.x = -80; d.boomVx = Math.abs(d.boomVx); }
          if (d.x > 1840) { d.x = 1840; d.boomVx = -Math.abs(d.boomVx); }
          d.boomRot += d.boomRotSpeed * dt;
          d.el.style.transform = `translate3d(${d.x}px,${d.y}px,0) rotate(${d.boomRot}deg)`;
          continue;
        }

        // === FIGHT ===
        if (activeEvent === 'fight') {
          if (d.fightDead) { d.el.style.opacity = 0; continue; }
          const fs = fightState;
          if (fs) {
            if (fs.phase === 'lineup') {
              // Float to sides
              const targetX = d.fightSide === 'left' ? d.fightSlotX : d.fightSlotX;
              const targetY = d.fightSlotY;
              d.x += (targetX - d.x) * 0.05 * dt;
              d.y += (targetY - d.y) * 0.05 * dt;
              // Idle bobbing
              const bob = Math.sin(now / 600 + d.fightPhase) * 4;
              d.el.style.transform = `translate3d(${d.x}px,${d.y + bob}px,0)`;
            } else if (fs.phase === 'fighting') {
              // Each fighter has their own orbit target that shifts over time
              // Left team fights on the left-center, right team on the right-center
              const baseX = d.fightSide === 'left' ? 700 : 1100;
              const orbitX = baseX + Math.sin(now / 800 + d.fightPhase * 3) * 200;
              const orbitY = d.fightSlotY + Math.cos(now / 600 + d.fightPhase * 2) * 80;
              
              // Charge toward their orbit point with some chaos
              d.x += (orbitX - d.x) * 0.03 * dt + Math.sin(now/200 + d.fightPhase) * 3 * dt;
              d.y += (orbitY - d.y) * 0.03 * dt + Math.cos(now/250 + d.fightPhase) * 2 * dt;
              
              // Occasional lunge toward the enemy side
              const lunge = Math.sin(now / 400 + d.fightPhase * 5);
              if (lunge > 0.7) {
                const enemyDir = d.fightSide === 'left' ? 1 : -1;
                d.x += enemyDir * 4 * dt;
              }
              
              // Keep in bounds with margin
              if (d.x < 300) d.x = 300; if (d.x > 1600) d.x = 1600;
              if (d.y < 120) d.y = 120; if (d.y > 880) d.y = 880;
              
              const shake = Math.sin(now / 50 + d.fightPhase) * 3;
              d.el.style.transform = `translate3d(${d.x}px,${d.y + shake}px,0)`;
            } else if (fs.phase === 'victory') {
              // Winners dance in center
              if (d.fightDead) { d.el.style.opacity = 0; continue; }
              const bob = Math.sin(now / 300 + d.fightPhase) * 15;
              const sway = Math.sin(now / 500 + d.fightPhase) * 10;
              d.el.style.transform = `translate3d(${d.x + sway}px,${d.y + bob}px,0) scale(1.3)`;
            }
          }
          continue;
        }

        // === RAIN ===
        if (rainMode) {
          d.el.style.opacity = 1; d.y += d.rainSpeed * dt;
          d.x = d.rainOriginX + Math.sin((now/800)+d.rainPhase)*20;
          d.el.style.transform = `translate3d(${d.x}px,${d.y}px,0)`;
          if (d.y > 1100) { d.y = -180; d.rainOriginX = Math.random()*1800; }
          continue;
        }

        // === DYING ===
        if (d.dying) {
          d.vy += 0.5*dt; d.y += d.vy*dt; d.rot += 5*dt;
          d.el.style.transform = `translate3d(${d.x}px,${d.y}px,0) rotate(${d.rot}deg)`;
          d.el.style.opacity = (1 - d.y/1500);
          if (d.y > 1200) { d.el.remove(); activeCodes.delete(d.code); drawings.splice(i,1); }
          continue;
        }

        // === NORMAL WALK ===
        d.el.style.opacity = 1;
        d.x += d.speed * globalSpeedMultiplier * dt;
        if (d.x > 2200) {
          d.loops++;
          if (d.loops >= 1) d.el.classList.remove('jumping');
          const oldLane = d.lane;
          const nl = Math.floor(Math.random()*LANES.length);
          d.lane=nl; d.y=LANES[nl]; d.speed=SPEEDS[nl]; d.el.style.zIndex=Z_INDEXES[nl];
          d.x = getMinXInLane(nl, d) - 350;
          logConsole('lane', `<b>${d.user}</b> loop #${d.loops} ‚Üí carril ${nl+1} ${oldLane!==nl?'(cambi√≥)':'(mismo)'}`);
        }
        d.el.style.transform = `translate3d(${d.x}px,${d.y}px,0)`;
      }
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    // ==============================================================
    //  TWITCH
    // ==============================================================
    function connectTwitch() {
      if (ws) { try{ws.close();}catch(e){} }
      const s = document.getElementById('status');
      s.style.display='block'; s.innerText="CONECTANDO A: "+CHANNEL.toUpperCase();
      ws = new WebSocket('wss://irc-ws.chat.twitch.tv:443');
      ws.onopen = () => {
        s.innerText="¬°CONECTADO!"; setTimeout(()=>{s.style.display='none';},3000);
        ws.send('CAP REQ :twitch.tv/tags'); ws.send('PASS oauth:none');
        ws.send('NICK justinfan'+Math.floor(Math.random()*99999));
        ws.send('JOIN #'+CHANNEL.toLowerCase());
      };
      ws.onclose = () => { s.innerText="DESCONECTADO"; s.style.display='block'; setTimeout(connectTwitch,3000); };
      ws.onerror = (e) => console.error('WS error',e);
      ws.onmessage = (e) => handleMessage(e.data);
    }

    function handleMessage(data) {
      if (data.startsWith('PING')) { ws.send('PONG :tmi.twitch.tv'); return; }
      if (data.indexOf('PRIVMSG') === -1) return;
      const parts = data.split('PRIVMSG #'+CHANNEL.toLowerCase()+' :');
      if (!parts[1]) return;
      const msg = parts[1].trim();
      const rawTags = data.split('PRIVMSG')[0];
      const userMatch = data.match(/:(\w+)!/);
      const user = userMatch ? userMatch[1].toLowerCase() : 'unknown';
      const isSub = /subscriber=1/.test(rawTags) || /badges=[^;]*(?:subscriber|founder)/.test(rawTags);
      const isAdmin = (user === CHANNEL.toLowerCase());
      const args = msg.split(' ');
      const cmd = args[0].toLowerCase();
      const argT = args[1] ? args[1].replace('@','').toLowerCase() : null;

      if (cmd === '!dibujar' && args[1]) createDrawing(user, args[1], isSub, false);
      else if (cmd === '!borrar') { if(isAdmin&&argT) removeLastDrawing(argT); else removeLastDrawing(user); }
      else if (cmd === '!limpiar') { if(isAdmin&&argT) removeAllDrawingsForUser(argT); else if(isAdmin) removeAllDrawingsGlobal(); else removeAllDrawingsForUser(user); }
      else if (cmd === '!test' && isAdmin) toggleTest();
      else if (cmd === '!fin' && isAdmin) toggleRain();
      else if (cmd === '!boom' && isAdmin) triggerBoom();
      else if (cmd === '!pogo' && isAdmin) triggerPogo();
      else if (cmd === '!fight' && isAdmin) triggerFight();
      else if (cmd === '!volcan' && isAdmin) triggerVolcano();
      else if (cmd === '!salto' && isAdmin) triggerConfetti();
      else if (cmd === '!velocidad' && isAdmin) {
        if (args[1]==='1') { globalSpeedMultiplier=0.54; logConsole('speed','Vel ‚Üí 1'); }
        else if (args[1]==='2') { globalSpeedMultiplier=1.0; logConsole('speed','Vel ‚Üí 2'); }
      }
    }

    // === BORRADO ===
    function removeLastDrawing(u) {
      for (let i=drawings.length-1;i>=0;i--) { if(drawings[i].user===u){drawings[i].el.remove();activeCodes.delete(drawings[i].code);drawings.splice(i,1);return;} }
    }
    function removeAllDrawingsForUser(u) {
      drawings=drawings.filter(d=>{if(d.user===u){d.el.remove();activeCodes.delete(d.code);return false;}return true;});
    }
    function removeAllDrawingsGlobal() {
      drawings.forEach(d=>d.el.remove()); drawings=[];activeCodes.clear();subQueue=[];isShowcaseBusy=false;
    }

    // === CREAR DIBUJO ===
    function createDrawing(user, fullCode, isSub, isTest, forceX) {
      if (fullCode) fullCode = fullCode.replace(/=+$/,'');
      if (!isTest && activeCodes.has(fullCode)) return;
      try {
        let pixelData=[], finalPalette=[];
        const isV2 = fullCode.indexOf('v2')===0;
        if (isV2) {
          const c=fullCode.substring(2); const [h,p]=c.split('_');
          if(!h||!p) return; finalPalette.push('transparent');
          for(let i=0;i<h.length;i+=6) finalPalette.push('#'+h.substring(i,i+6));
          const b=atob(p);
          for(let i=0;i<b.length;i++){const v=b.charCodeAt(i);pixelData.push((v>>4)&0x0F,v&0x0F);}
        } else {
          const [h,p]=fullCode.split('_'); if(!h||!p) return;
          const sl=p.length-(p.length%2);
          for(let i=0;i<sl;i+=2){const ci=parseInt(p[i],16),cn=parseInt(p[i+1],36);if(isNaN(ci)||isNaN(cn)||cn>256)continue;for(let j=0;j<cn;j++)pixelData.push(ci);}
          for(let i=0;i<h.length;i++){if(h[i]==='1'&&h[i+1]==='0'){finalPalette.push(colors[16]);i++;}else finalPalette.push(colors[parseInt(h[i],16)]);}
        }
        if(!pixelData.length||!finalPalette.length) return;

        const itemEl=document.createElement('div'); itemEl.className='item';
        const canvas=document.createElement('canvas'); canvas.className='pixel-art'; canvas.width=16;canvas.height=16;
        const ctx=canvas.getContext('2d');
        pixelData.forEach((idx,k)=>{if(finalPalette[idx]&&finalPalette[idx]!=='transparent'){ctx.fillStyle=finalPalette[idx];ctx.fillRect(k%16,Math.floor(k/16),1,1);}});

        if(isSub){itemEl.classList.add('is-sub');if(!isTest)itemEl.classList.add('waiting');}
        if(!isSub) itemEl.classList.add('jumping');
        if(testMode&&!isTest) itemEl.classList.add('hidden');
        itemEl.appendChild(canvas);
        const nickEl=document.createElement('div');nickEl.className='nick';nickEl.innerText=(isSub?'‚≠ê ':'')+user;
        itemEl.appendChild(nickEl);

        const laneIdx=drawings.length%4;
        itemEl.style.zIndex=Z_INDEXES[laneIdx];
        document.getElementById('container').appendChild(itemEl);

        let obj={el:itemEl,user,code:fullCode,lane:laneIdx,speed:SPEEDS[laneIdx],y:LANES[laneIdx],x:forceX||-400,isTest,dying:false,vy:0,rot:0,rainOriginX:0,rainSpeed:1,rainPhase:0,loops:0,boomVx:0,boomVy:0,boomRot:0,boomRotSpeed:0,fightSide:null,fightSlotX:0,fightSlotY:0,fightPhase:Math.random()*7,fightDead:false};
        if(forceX===undefined) obj.x=getMinXInLane(laneIdx,null)-350;
        obj.rainOriginX=obj.x;
        drawings.push(obj);
        if(!isTest) activeCodes.add(fullCode);
        if(isSub){subQueue.push(obj);processQueue();}
        logConsole(isSub?'sub':'user',`<b>${user}</b> ‚Üí carril ${laneIdx+1} (${isSub?'SUB':'normal'})`);
      } catch(e){console.error(e);}
    }

    // === SHOWCASE + ESPIRAL ===
    function processQueue() {
      if (!isShowcaseBusy && subQueue.length > 0) {
        isShowcaseBusy = true;
        const cur = subQueue.shift();
        cur.el.classList.remove('waiting','hidden');
        cur.el.classList.add('showcase');
        logConsole('sub', `üéâ <b>${cur.user}</b> BAILANDO`);
        setTimeout(() => {
          cur.el.classList.remove('showcase');
          // If any event is active, join it directly
          if (isEventActive()) {
            cur.el.style.transform='';
            cur.x=960; cur.y=540;
            if (activeEvent==='boom') assignBoomPhysics(cur);
            else if (activeEvent==='pogo') { assignBoomPhysics(cur); cur.boomVy=-14; cur.y=400; }
            else if (activeEvent==='volcano') { cur.x=880+(Math.random()-0.5)*160; cur.y=1080; cur.boomVy=-(18+Math.random()*16); cur.boomVx=(Math.random()-0.5)*12; cur.boomRot=0; cur.boomRotSpeed=(Math.random()-0.5)*10; }
            else if (activeEvent==='confetti') { cur.x=Math.random()*1800; cur.y=950; cur.boomVy=-(12+Math.random()*18); cur.boomVx=(Math.random()-0.5)*10; cur.boomRot=0; cur.boomRotSpeed=(Math.random()-0.5)*14; }
            else if (activeEvent==='fight') {
              cur.fightSide = Math.random()<0.5?'left':'right';
              cur.fightSlotX = cur.fightSide==='left'?100+Math.random()*150:1650+Math.random()*150;
              cur.fightSlotY = 200+Math.random()*600;
            }
            logConsole('event', `<b>${cur.user}</b> se une al evento ${activeEvent}`);
            isShowcaseBusy=false; processQueue(); return;
          }
          // Normal spiral
          cur.el.classList.add('spiral-to-lane');
          logConsole('sub', `üåÄ <b>${cur.user}</b> espiral ‚Üí carril ${cur.lane+1}`);
          const tX=50, tY=LANES[cur.lane], sX=960, sY=540, sS=4.1, eS=1, spins=4, dur=1400;
          const st=performance.now();
          function step(now){
            const p=Math.min((now-st)/dur,1), e=1-Math.pow(1-p,3);
            cur.el.style.transform=`translate3d(${sX+(tX-sX)*e}px,${sY+(tY-sY)*e}px,0) scale(${sS+(eS-sS)*e}) rotate(${spins*360*p}deg)`;
            if(p<1){requestAnimationFrame(step);}
            else{
              cur.el.classList.remove('spiral-to-lane');cur.el.style.transform='';
              cur.x=tX;cur.y=tY;
              if(isEventActive()){
                if(activeEvent==='boom')assignBoomPhysics(cur);
                else if(activeEvent==='pogo'){assignBoomPhysics(cur);cur.boomVy=-14;cur.y=400;}
                else if(activeEvent==='volcano'){cur.x=880+(Math.random()-0.5)*160;cur.y=1080;cur.boomVy=-(18+Math.random()*16);cur.boomVx=(Math.random()-0.5)*12;cur.boomRot=0;cur.boomRotSpeed=(Math.random()-0.5)*10;}
                else if(activeEvent==='confetti'){cur.x=Math.random()*1800;cur.y=950;cur.boomVy=-(12+Math.random()*18);cur.boomVx=(Math.random()-0.5)*10;cur.boomRot=0;cur.boomRotSpeed=(Math.random()-0.5)*14;}
              } else { cur.el.classList.add('jumping'); cur.loops=0; }
              logConsole('sub',`‚úÖ <b>${cur.user}</b> aterriz√≥`);
              isShowcaseBusy=false; processQueue();
            }
          }
          requestAnimationFrame(step);
        }, 10000);
      }
    }

    // ==============================================================
    //  EVENTS
    // ==============================================================

    // --- BOOM ---
    function triggerBoom() {
      if (activeEvent === 'boom') { endEvent(); return; }
      if (isEventActive()) endEvent();
      if (drawings.length < 2) { logConsole('boom','Necesit√°s al menos 2 dibujos'); return; }
      activeEvent = 'boom'; rainMode = false;
      logConsole('boom', `üí•üí•üí• BOOM ‚Äî ${drawings.length} dibujos, 30s`);
      drawings.forEach(d => {
        if (d.el.classList.contains('showcase')||d.el.classList.contains('waiting')||d.el.classList.contains('spiral-to-lane')) return;
        assignBoomPhysics(d);
      });
      eventTimer = setTimeout(endEvent, 30000);
    }

    // --- POGO ---
    function triggerPogo() {
      if (activeEvent === 'pogo') { endEvent(); return; }
      if (isEventActive()) endEvent();
      if (drawings.length < 2) { logConsole('pogo','Necesit√°s al menos 2 dibujos'); return; }
      activeEvent = 'pogo'; rainMode = false;
      logConsole('pogo', `ü¶òü¶òü¶ò POGO ‚Äî ${drawings.length} dibujos rebotando en el suelo, 30s`);
      drawings.forEach(d => {
        if (d.el.classList.contains('showcase')||d.el.classList.contains('waiting')||d.el.classList.contains('spiral-to-lane')) return;
        d.el.classList.remove('jumping');
        d.boomVx = (Math.random()-0.5) * 8;
        d.boomVy = -(14 + Math.random()*10); // big initial launch upward
        d.boomRot = 0;
        d.boomRotSpeed = (Math.random()-0.5)*10;
      });
      eventTimer = setTimeout(endEvent, 30000);
    }

    // --- VOLCANO ---
    function triggerVolcano() {
      if (activeEvent === 'volcano') { endEvent(); return; }
      if (isEventActive()) endEvent();
      if (drawings.length < 2) { logConsole('volcano','Necesit√°s al menos 2 dibujos'); return; }
      activeEvent = 'volcano'; rainMode = false;
      logConsole('volcano', `üåãüåãüåã VOLC√ÅN ‚Äî ${drawings.length} dibujos erupcionando, 30s`);
      drawings.forEach(d => {
        if (d.el.classList.contains('showcase')||d.el.classList.contains('waiting')||d.el.classList.contains('spiral-to-lane')) return;
        d.el.classList.remove('jumping');
        // Start all at the volcano mouth (bottom center)
        d.x = 880 + (Math.random() - 0.5) * 160;
        d.y = 1080;
        d.boomVy = -(18 + Math.random() * 16); // massive upward blast, staggered
        d.boomVx = (Math.random() - 0.5) * 12; // fan out horizontally
        d.boomRot = 0;
        d.boomRotSpeed = (Math.random() - 0.5) * 10;
        d.fightPhase = Math.random() * 7; // for wind drift variation
      });
      eventTimer = setTimeout(endEvent, 30000);
    }

    // --- CONFETTI (Salto) ---
    function triggerConfetti() {
      if (activeEvent === 'confetti') { endEvent(); return; }
      if (isEventActive()) endEvent();
      if (drawings.length < 2) { logConsole('confetti','Necesit√°s al menos 2 dibujos'); return; }
      activeEvent = 'confetti'; rainMode = false;
      logConsole('confetti', `üéäüéäüéä SALTO ‚Äî ${drawings.length} dibujos como papel picado, 30s`);
      drawings.forEach(d => {
        if (d.el.classList.contains('showcase')||d.el.classList.contains('waiting')||d.el.classList.contains('spiral-to-lane')) return;
        d.el.classList.remove('jumping');
        // Spread across the full width, start from bottom
        d.x = Math.random() * 1800;
        d.y = 950;
        d.boomVy = -(12 + Math.random() * 18); // strong upward launch
        d.boomVx = (Math.random() - 0.5) * 10;
        d.boomRot = 0;
        d.boomRotSpeed = (Math.random() - 0.5) * 14; // lots of spin
        d.fightPhase = Math.random() * 7;
      });
      eventTimer = setTimeout(endEvent, 30000);
    }

    // --- FIGHT ---
    function triggerFight() {
      if (activeEvent === 'fight') { endEvent(); return; }
      if (isEventActive()) endEvent();
      const eligible = drawings.filter(d => !d.el.classList.contains('showcase')&&!d.el.classList.contains('waiting')&&!d.el.classList.contains('spiral-to-lane'));
      if (eligible.length < 4) { logConsole('fight','Necesit√°s al menos 4 dibujos'); return; }
      
      activeEvent = 'fight'; rainMode = false;
      logConsole('fight', `‚öîÔ∏è‚öîÔ∏è‚öîÔ∏è FIGHT ‚Äî ${eligible.length} dibujos`);

      // Shuffle and split into two teams
      const shuffled = eligible.sort(() => Math.random()-0.5);
      const half = Math.ceil(shuffled.length/2);
      const leftTeam = shuffled.slice(0, half);
      const rightTeam = shuffled.slice(half);

      // Assign individual HP + positions
      leftTeam.forEach((d, i) => {
        d.fightSide = 'left'; d.fightDead = false;
        d.el.classList.remove('jumping');
        d.fightHP = 2 + Math.floor(Math.random() * 4); // 2-5 HP each
        d.fightMaxHP = d.fightHP;
        d.fightSlotX = 80 + (i % 3) * 120;
        d.fightSlotY = 150 + Math.floor(i / 3) * 180 + (i%2)*30;
        d.fightPhase = Math.random()*7;
      });
      rightTeam.forEach((d, i) => {
        d.fightSide = 'right'; d.fightDead = false;
        d.el.classList.remove('jumping');
        d.fightHP = 2 + Math.floor(Math.random() * 4); // 2-5 HP each
        d.fightMaxHP = d.fightHP;
        d.fightSlotX = 1550 + (i % 3) * 120;
        d.fightSlotY = 150 + Math.floor(i / 3) * 180 + (i%2)*30;
        d.fightPhase = Math.random()*7;
      });

      // Total team HP = sum of individual HPs
      const leftTotalHP = leftTeam.reduce((s,d) => s + d.fightHP, 0);
      const rightTotalHP = rightTeam.reduce((s,d) => s + d.fightHP, 0);

      // Kill interval scales with fighter count: more fighters = faster hits
      // Base interval ~1.5s, scales down with more fighters, min 0.6s
      const totalFighters = eligible.length;
      const baseInterval = Math.max(600, 1500 - totalFighters * 50);

      fightState = {
        phase: 'lineup',
        leftTeam, rightTeam,
        leftTotalHP: leftTotalHP, rightTotalHP: rightTotalHP,
        leftMaxHP: leftTotalHP, rightMaxHP: rightTotalHP,
        nextHitTime: 0,
        baseInterval: baseInterval
      };

      // Show HUD
      const hud = document.getElementById('fight-hud');
      hud.style.display = 'block';
      document.getElementById('hp-left').style.width = '100%';
      document.getElementById('hp-right').style.width = '100%';
      document.getElementById('hp-label-left').textContent = `üî¥ EQUIPO ROJO (${leftTeam.length})`;
      document.getElementById('hp-label-right').textContent = `üîµ EQUIPO AZUL (${rightTeam.length})`;
      document.getElementById('fight-text').style.display = 'none';
      document.getElementById('fight-winner-text').style.display = 'none';

      logConsole('fight', `Equipo üî¥ (${leftTeam.length}, HP total: ${leftTotalHP}): ${leftTeam.map(d=>d.user+'['+d.fightHP+'hp]').join(', ')}`);
      logConsole('fight', `Equipo üîµ (${rightTeam.length}, HP total: ${rightTotalHP}): ${rightTeam.map(d=>d.user+'['+d.fightHP+'hp]').join(', ')}`);

      // After 8s lineup, show FIGHT!, then start fighting
      setTimeout(() => {
        if (activeEvent !== 'fight') return;
        const ft = document.getElementById('fight-text');
        ft.style.display = 'block';
        logConsole('fight', 'üîî FIGHT!');
        setTimeout(() => {
          ft.style.display = 'none';
          if (activeEvent !== 'fight' || !fightState) return;
          fightState.phase = 'fighting';
          fightState.nextHitTime = Date.now() + 1000 + Math.random() * fightState.baseInterval;
        }, 2000);
      }, 8000);
    }

    function fightTick(dt) {
      if (!fightState || fightState.phase !== 'fighting') return;
      const now = Date.now();
      
      if (now >= fightState.nextHitTime) {
        const leftAlive = fightState.leftTeam.filter(d => !d.fightDead);
        const rightAlive = fightState.rightTeam.filter(d => !d.fightDead);
        if (leftAlive.length === 0 || rightAlive.length === 0) { finishFight(); return; }

        // Pick attacker side randomly, the other side takes damage
        const attackSide = Math.random() < 0.5 ? 'left' : 'right';
        const defenders = attackSide === 'left' ? rightAlive : leftAlive;
        
        // Pick a random defender to take a hit
        const target = defenders[Math.floor(Math.random() * defenders.length)];
        target.fightHP--;

        // Flash the hit target briefly
        target.el.style.filter = 'brightness(3)';
        setTimeout(() => { if (!target.fightDead) target.el.style.filter = ''; }, 150);

        // Update team total HP
        if (attackSide === 'left') fightState.rightTotalHP--;
        else fightState.leftTotalHP--;

        // Update HP bars
        document.getElementById('hp-left').style.width = Math.max(0, fightState.leftTotalHP / fightState.leftMaxHP * 100) + '%';
        document.getElementById('hp-right').style.width = Math.max(0, fightState.rightTotalHP / fightState.rightMaxHP * 100) + '%';

        // Did the target die?
        if (target.fightHP <= 0) {
          target.fightDead = true;
          spawnExplosion(target.x, target.y);
          target.el.style.transition = 'transform 0.3s ease-out, opacity 0.3s ease-out';
          target.el.style.transform += ' scale(1.5)';
          target.el.style.opacity = 0;
          target.el.style.filter = '';
          setTimeout(() => { target.el.style.transition = ''; }, 350);

          const defSide = attackSide === 'left' ? 'üîµ' : 'üî¥';
          logConsole('fight', `üíÄ <b>${target.user}</b> (${defSide}) MUERTO! [üî¥ ${fightState.leftTeam.filter(d=>!d.fightDead).length} vs ${fightState.rightTeam.filter(d=>!d.fightDead).length} üîµ]`);

          // Check if a full team is wiped
          const leftRemain = fightState.leftTeam.filter(d => !d.fightDead).length;
          const rightRemain = fightState.rightTeam.filter(d => !d.fightDead).length;
          if (leftRemain === 0 || rightRemain === 0) {
            finishFight();
            return;
          }
        } else {
          const defSide = attackSide === 'left' ? 'üîµ' : 'üî¥';
          logConsole('fight', `‚öîÔ∏è <b>${target.user}</b> (${defSide}) recibe golpe! HP: ${target.fightHP}/${target.fightMaxHP}`);
        }

        // Next hit: random interval around baseInterval
        fightState.nextHitTime = now + fightState.baseInterval * (0.5 + Math.random());
      }
    }

    function finishFight() {
      if (!fightState) return;
      if (eventTimer) { clearTimeout(eventTimer); eventTimer = null; }
      fightState.phase = 'victory';

      const leftRemain = fightState.leftTeam.filter(d => !d.fightDead);
      const rightRemain = fightState.rightTeam.filter(d => !d.fightDead);
      const winningSide = leftRemain.length > 0 ? 'left' : 'right';
      const winners = winningSide === 'left' ? leftRemain : rightRemain;
      const sideEmoji = winningSide === 'left' ? 'üî¥' : 'üîµ';
      const sideName = winningSide === 'left' ? 'ROJO' : 'AZUL';

      logConsole('fight', `üèÜ EQUIPO ${sideEmoji} ${sideName} GANA! Sobrevivientes: ${winners.map(d=>d.user).join(', ')}`);

      // Show winner text
      const wt = document.getElementById('fight-winner-text');
      wt.textContent = `üèÜ EQUIPO ${sideName} GANA!`;
      wt.style.display = 'block';

      // Position winners in center for victory dance
      winners.forEach((d, i) => {
        d.el.style.opacity = 1;
        const spacing = Math.min(200, 800 / winners.length);
        d.x = 960 - (winners.length-1)*spacing/2 + i*spacing;
        d.y = 480;
      });

      // After 8s of victory dance, end the event
      setTimeout(() => {
        document.getElementById('fight-hud').style.display = 'none';
        // Restore all (including "dead" ones)
        drawings.forEach(d => { d.fightDead = false; d.el.style.opacity = 1; });
        endEvent();
      }, 8000);
    }

    // ==============================================================
    //  RANDOM EVENT SCHEDULER
    // ==============================================================
    function scheduleNextRandomEvent() {
      if (randomEventScheduler) clearTimeout(randomEventScheduler);
      // Random interval between 17 and 25 minutes (in ms)
      const minMs = 17 * 60 * 1000, maxMs = 25 * 60 * 1000;
      const delay = minMs + Math.random() * (maxMs - minMs);
      const mins = (delay/60000).toFixed(1);
      logConsole('event', `‚è∞ Pr√≥ximo evento aleatorio en ~${mins} min`);
      
      randomEventScheduler = setTimeout(() => {
        if (isEventActive() || isShowcaseBusy) {
          // Retry in 1 min if busy
          logConsole('event', '‚è≥ Evento pospuesto (ocupado), reintentando en 1min');
          randomEventScheduler = setTimeout(() => scheduleNextRandomEvent(), 60000);
          return;
        }
        if (drawings.length < 4) {
          logConsole('event', '‚è≥ No hay suficientes dibujos, reintentando en 2min');
          randomEventScheduler = setTimeout(() => scheduleNextRandomEvent(), 120000);
          return;
        }
        // Pick a random event
        const events = ['boom', 'pogo', 'fight', 'volcano', 'confetti'];
        const pick = events[Math.floor(Math.random()*events.length)];
        logConsole('event', `üé≤ Evento aleatorio: <b>${pick.toUpperCase()}</b>`);
        
        if (pick === 'boom') triggerBoom();
        else if (pick === 'pogo') triggerPogo();
        else if (pick === 'fight') triggerFight();
        else if (pick === 'volcano') triggerVolcano();
        else if (pick === 'confetti') triggerConfetti();

        // Schedule next after this one ends
        // Wait for current event to finish + schedule
        const waitForEnd = setInterval(() => {
          if (!isEventActive()) {
            clearInterval(waitForEnd);
            scheduleNextRandomEvent();
          }
        }, 1000);
      }, delay);
    }

    // Start scheduler on connection
    function startRandomEvents() {
      scheduleNextRandomEvent();
    }

    // ==============================================================
    //  TEST PANEL
    // ==============================================================
    function testAddUser() {
      testUserCounter++;
      createDrawing(RANDOM_NAMES[Math.floor(Math.random()*RANDOM_NAMES.length)]+'_'+testUserCounter, TEST_CODE, false, true);
    }
    function testAddSub() {
      testUserCounter++;
      createDrawing(RANDOM_NAMES[Math.floor(Math.random()*RANDOM_NAMES.length)]+'_'+testUserCounter, TEST_CODE, true, true);
    }
    function testSpeed(level) {
      if(level===1)globalSpeedMultiplier=0.54; else globalSpeedMultiplier=1.0;
      document.getElementById('btn-spd1').classList.toggle('active',level===1);
      document.getElementById('btn-spd2').classList.toggle('active',level===2);
      logConsole('speed',`Velocidad ‚Üí ${level}`); updateConsoleStats();
    }

    let testSpawnTimer = null;
    function toggleTest() {
      testMode = !testMode;
      const bar = document.getElementById('test-bar');
      if (testMode) {
        drawings.forEach(d=>{if(!d.isTest)d.el.classList.add('hidden');});
        bar.style.display='flex';
        document.getElementById('test-console-body').innerHTML='';
        document.getElementById('btn-spd1').classList.toggle('active',globalSpeedMultiplier<0.9);
        document.getElementById('btn-spd2').classList.toggle('active',globalSpeedMultiplier>=0.9);
        logConsole('info','üß™ Modo test ACTIVADO');

        let bi=0;
        testSpawnTimer=setInterval(()=>{
          if(bi>=8||!testMode){clearInterval(testSpawnTimer);testSpawnTimer=null;return;}
          testUserCounter++;
          createDrawing(RANDOM_NAMES[Math.floor(Math.random()*RANDOM_NAMES.length)]+'_'+testUserCounter,TEST_CODE,Math.random()<0.15,true);
          bi++;
        },800);
      } else {
        if(testSpawnTimer){clearInterval(testSpawnTimer);testSpawnTimer=null;}
        if(eventTimer){clearTimeout(eventTimer);eventTimer=null;}
        activeEvent=null; fightState=null; rainMode=false;
        document.getElementById('fight-hud').style.display='none';
        bar.style.display='none';
        drawings=drawings.filter(d=>{if(d.isTest){d.el.remove();return false;}d.el.classList.remove('hidden');return true;});
      }
    }

    function toggleRain() {
      if(isEventActive()){endEvent();}
      rainMode=!rainMode;
      logConsole('rain',rainMode?'üåßÔ∏è Lluvia ACTIVADA':'‚òÄÔ∏è Lluvia DESACTIVADA');
      drawings.forEach(d=>{
        if(rainMode){d.rainOriginX=d.x;d.rainSpeed=0.8+Math.random()*2;d.rainPhase=Math.random()*7;}
        else{d.y=LANES[d.lane];}
      });
    }

    connectTwitch();
    // Start random event scheduler after a short delay
    setTimeout(startRandomEvents, 5000);
  </script>
</body>
</html>
